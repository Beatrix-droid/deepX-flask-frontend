from flask import Flask, render_template, flash, redirect, url_for, request
from flask_wtf import FlaskForm
from flask_wtf.file import FileField, FileRequired, FileAllowed
from werkzeug.utils import secure_filename
import os
from dotenv import load_dotenv
from threading import Lock
#from mask import *
import tensorflow as tf
from PIL import Image
import numpy as np
from predict import *
from generate_im import save_from_arr


load_dotenv()

#environment variables

lock = Lock()
app = Flask(__name__)
app.config['SECRET_KEY']= os.getenv("SECRET")
app.config['UPLOAD_FOLDER'] = 'uploads'
app.config["MAX_CONTENT_LENGTH"] = 4*1024*1024 #4MB max-limit


class UploadImage(FlaskForm):
    file = FileField(validators=[FileRequired(), FileAllowed(['png', 'jpeg'], 'Images only!')]) #allow only files with the jpg extension to be submitted


@app.route('/upload', methods=['GET', 'POST'])
def upload():

    """uploads an image, creates a mask and places file in static/masks and displays it to end user"""

    form = UploadImage()

    #if client attempts to submit the form (ie sends a POST request)
    if request.method =="POST":

        #check if the file  the client wants to upload matches the specified requirements
        if form.validate_on_submit():

            #if the file meets the requirements acquire a lock so that only this one user can write to the upload directory
            lock.acquire()

            #first check if "upload" directory is empty. If the directory is not empty,
             # delete any files that are in it: the "upload" directory functions as a 'temporary' directory, and we
            # only want the one image the current client uploads to the server to ever be there

            if len(os.listdir("static/uploads")) != 0:
                for f in  os.listdir("static/uploads"):
                    path_to_file = os.path.join("static/uploads", f)
                    os.remove(path_to_file)

            filename = secure_filename(form.file.data.filename)
            form.file.data.save('static/uploads/' + filename) #grab the file and save it in the uploads directory
            flash("Image uploaded successfully.")





            #if len(os.listdir("static/masks")) != 0:
             #   for f in  os.listdir("static/masks"):
              #      path_to_file = os.path.join("static/masks", f)
               #     os.remove(path_to_file)

            #preprocess image uploaded by the user
            #image = load_image('uploads/' + filename)



            #gray_image = grey_image(image)
            #blurred_image = blur_image(gray_image)
            #t = find_threshold(blurred_image)
            #binary_mask = create_mask(t, blurred_image)

            #lock.acquire() #acquire lock when writing to another file
            #save_mask(binary_mask)


            #load model
            A = os.path.dirname(os.path.realpath(__file__))
            model = tf.keras.models.load_model(os.path.join(A,"finalmodel.h5"))

            test = preproc('static/uploads/' + filename)
            output = predict_image(model, test)

            #feed mask to model
            #open_image = Image.open("static/masks/mask.jpg").convert("RGB")
            #open_image = open_image.resize((256, 256))
            #open_image = np.array(open_image)
            #image = predict_image(model,open_image )
            save_from_arr(output, "static/Model_output/generated_im.jpg")



            #next put a lock on the model_output directory
            #first check that the model ouput folder is empty and if its not empty it
            # (it too should be a temporary directory that stores
            # only one file, the file that the model generates for the user that last uploaded an image)


            #lock.acquire()
           # if len(os.listdir("static/Model_output")) != 0:
            #    for f in  os.listdir("Model_output"):
             #       path_to_file = os.path.join("Model_output", f)
              #      os.remove(path_to_file)


            #preprocess image, load the model and generate the output mage:

                #INSERT PREPROCESSING AND MODEL LOADING CODE HERE

            #save the file generated by the model in Model.outputs
            #lock.release()
            #path where the final imnage of the model will be stored (must be a subdirectory of the static directory because
            # this is where the FLASK frameworks looks for images)
            model_output = "static/Model_output/generated_im.jpg"
            user_upload = f"static/uploads/{filename}"

            lock.release() #release the lock on the upload folder so that another incoming client can write to it.

            return render_template(f"index.html", form=form, model_output=model_output, user_upload=user_upload)

        else:
            ##flash message if client uploads file that is too large

            if app.config["MAX_CONTENT_LENGTH"] > 4*1024*1024 :
                flash("File is too big. Please Upload a smaller file")
                return redirect(url_for('upload')+"#UseDeepX")

            #flash message if client uploads file with wrong extension

            flash("Allowed image types are only jpegs")
            return redirect(url_for('upload')+"#UseDeepX")

    #else just return the page if client submits a GET request (ie just requests the page to the server)
    return render_template("index.html",form=form)

if __name__ == '__main__':
    app.run(debug=True)
